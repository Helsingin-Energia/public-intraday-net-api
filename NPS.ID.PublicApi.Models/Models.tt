<#@ template language="C#" debug="false" hostSpecific="true" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>
<#@ output extension="/" #> 
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ Assembly Name="System.Web.Http.dll" #>
<#@ Assembly Name="System.Web.Routing" #>
<#@ Assembly Name="System.Web" #>
<#@ Assembly Name="System.Web.Mvc" #>
<#@ Assembly Name="System.Globalization" #>
<#@ assembly name="EnvDTE"#>
<#@ Assembly Name="Newtonsoft.Json" #>
<#@ Assembly Name="$(SolutionDir)\packages\NJsonSchema.9.6.5\lib\net45\NJsonSchema.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Web.Http" #>
<#@ import namespace="System.Web.Mvc" #>
<#@ import namespace="System.Web.Routing" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="NJsonSchema" #>
<#
	string schemaPath = Path.GetDirectoryName(Host.TemplateFile) + "/../../public-intraday-api-jsonschema/v1"; 
	string outputPath= Path.GetDirectoryName(Host.TemplateFile) + "/v1"; 
	if (!Directory.Exists(schemaPath))
    {
		throw new Exception("Invalid SchemaPath " + schemaPath);
    }
	
    var schemaRootFolder = new DirectoryInfo(schemaPath);
    var outputFolder = new DirectoryInfo(outputPath);
	Dictionary<string,JsonSchema4> schemaTypes = new Dictionary<string,JsonSchema4>();

	var hostServiceProvider = (IServiceProvider)this.Host;
	var dte = (DTE)hostServiceProvider.GetService(typeof(DTE));
	Project project = null;
    foreach (var item in dte.Solution.Projects)
    {
		//First project is Models - project
		 project = item as Project;
		 break;
    }

	foreach (FileInfo file in outputFolder.GetFiles())
	{
		file.Delete(); 
	}

	HandleFiles(schemaRootFolder, project);

#>
<#+

	public void HandleFiles(DirectoryInfo schemaFolder, Project project) {
		
		foreach (var subFolder in schemaFolder.EnumerateDirectories())
		{
			HandleFiles(subFolder, project);
		}
		foreach (var schemaFile in schemaFolder.EnumerateFiles())
		{
			try 
			{
				if(!schemaFile.Name.EndsWith(".json"))
					continue;
				//if(!schemaFile.Name.Contains("TradeRecallRequest"))
				//	continue;
				var schema = NJsonSchema.JsonSchema4.FromFileAsync(schemaFile.FullName).Result;
				var className = GetTypeNameFromDocumentFilePath(schema, false);
				WriteClass(className, schema);
				
				string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
				var folder= schemaFolder.FullName.Substring(schemaFolder.FullName.IndexOf("v1"));

				folder = Path.Combine(templateDirectory, folder);
				
				if(!Directory.Exists(folder))
					Directory.CreateDirectory(folder);
				var fileName = className + ".cs";
				SaveOutput(folder, fileName);
				IncludeCreatedFileToProject(project,Path.Combine(folder, fileName));

			} catch(Exception ex)
			{
				throw new Exception("Error when handling file " + schemaFile.FullName, ex);
			}
		}
    }

	public void WriteClass(string typeName, NJsonSchema.JsonSchema4 schema)
	{
		if(schema.IsEnumeration)
			WriteBeginBlock("enum", typeName, schema);
		else
			WriteBeginBlock("class", typeName, schema);
		if(schema.IsEnumeration)
			WriteEnumValues(schema);
		else
			WriteMembers(schema);
		WriteEndBlock();
	}

	public void WriteBeginBlock(string blockType, string typeName, NJsonSchema.JsonSchema4 schema)
	{
		var nameSpaceSuffix = GetNameSpaceSuffix(schema);
		if(!string.IsNullOrEmpty(nameSpaceSuffix))
			nameSpaceSuffix = "." + ApplyCamelCasing(nameSpaceSuffix);

		var usings = new List<string>();
		foreach(var property in schema.ActualProperties)
        {
			if(property.Value.HasSchemaReference) {
				usings.Add(ApplyCamelCasing(GetNameSpaceSuffix(property.Value.SchemaReference)));
            }
			if(property.Value.Type == NJsonSchema.JsonObjectType.Array) {
				if(property.Value.Item != null)
					usings.Add(ApplyCamelCasing(GetNameSpaceSuffix(property.Value.Item.SchemaReference)));
            }
        }

#>
/*
 *  Copyright 2017 Nord Pool.
 *  This library is intended to aid integration with Nord Pool’s Intraday API and comes without any warranty. Users of this library are responsible for separately testing and ensuring that it works according to their own standards.
 *  Please send feedback to idapi@nordpoolgroup.com.
 */

<#+
		foreach(var usingClause in usings.Distinct())
        {
#>
using  Nordpool.ID.PublicApi.v1.<#=usingClause#>;
<#+
        }
#>

namespace Nordpool.ID.PublicApi.v1<#=nameSpaceSuffix#>
{
<#+
		if(!string.IsNullOrEmpty(schema.Description))
        {
#>
	/// <summary><#=schema.Description#></summary>
<#+
        }
#>
	public <#=blockType#> <#=typeName#> <#=GetBaseClassDefinition(schema)#>
	{
<#+
}

	private static string GetFullNameSpace(NJsonSchema.JsonSchema4 schema)
    {
		if(schema.ExtensionData == null)
			return "";
		var extendsClause = schema.ExtensionData.Where(r=>r.Key == "javaType").FirstOrDefault();

		var suffix = "";
		if(extendsClause.Value == null)
			return "";
		else
			suffix =  extendsClause.Value.ToString();
		suffix = suffix.Replace("com.nordpool.id.publicapi.v1.", "");
		var typeName = GetTypeNameFromDocumentFilePath(schema, false);
		suffix = suffix.Replace(typeName, "");
		if(suffix == "")
			return "Nordpool.ID.PublicApi.v1";
		return "Nordpool.ID.PublicApi.v1." + ApplyCamelCasing(suffix.Trim('.'));

    }

	private static string GetNameSpaceSuffix(NJsonSchema.JsonSchema4 schema)
    {
		if(schema.ExtensionData == null)
			return "";
		var extendsClause = schema.ExtensionData.Where(r=>r.Key == "javaType").FirstOrDefault();

		var suffix = "";
		if(extendsClause.Value == null)
			return "";
		else
			suffix =  extendsClause.Value.ToString();
		suffix = suffix.Replace("com.nordpool.id.publicapi.v1.", "");
		var typeName = GetTypeNameFromDocumentFilePath(schema, false);
		suffix = suffix.Replace(typeName, "");

		return suffix.Trim('.');

    }

	private static string GetBaseClassDefinition(NJsonSchema.JsonSchema4 schema)
    {
		if(schema.ExtensionData == null)
			return "";

		var extendsClause = schema.ExtensionData.Where(r=>r.Key == "extends").FirstOrDefault();
		if(extendsClause.Value == null)
			return "";

		var extendsObject = extendsClause.Value as System.Collections.Generic.Dictionary<string, object>;
		var referencedSchemaPath = extendsObject.Where(r=>r.Key == "schemaReferencePath").FirstOrDefault().Value.ToString();
		var subFolderName = GetSubFolderFromReferencedSchemaPath(referencedSchemaPath);
		//name can contain ../base/
		var nameSpacePrefix = subFolderName.Replace("/",".").Trim('.');
		nameSpacePrefix = ApplyCamelCasing(nameSpacePrefix);
		if(!string.IsNullOrEmpty(nameSpacePrefix))
			nameSpacePrefix = nameSpacePrefix + ".";
		return " : " + nameSpacePrefix + GetTypeNameFromFilePath(referencedSchemaPath);
    }

	private static string GetSubFolderFromReferencedSchemaPath(string schemaPath) 
    {
		var typeName = GetTypeNameFromFilePath(schemaPath);
		
		return schemaPath.Replace(typeName, "").Replace(".json","");
	}

	public void WriteMembers(JsonSchema4 schema)
	{
		foreach(var property in schema.ActualProperties)
        {
			if(!string.IsNullOrEmpty(property.Value.Description))
            {
#>
		/// <summary><#=property.Value.Description#></summary>
<#+
            }
#>
		public <#=MapSchemaPropertyTypeToCSTypeName(property.Value.Type, property.Value)#> <#=ApplyCamelCasing(property.Key)#> { get; set; }

<#+
        }
	}

	public void WriteEnumValues(JsonSchema4 schema)
	{
		foreach(var enumValue in schema.Enumeration)
        {
			if(enumValue == null) continue;
#>
		<#=enumValue.ToString()#>,
<#+
        }
	}



	public void WriteEndBlock()
	{
#>
	}
}
<#+
	}

	private static string GetTypeNameFromDocumentFilePath(JsonSchema4 schema, bool includeFullyQualifiedNameSpace)
    {
		var typeName =  GetTypeNameFromFilePath(schema.DocumentPath);
		if(includeFullyQualifiedNameSpace) 
        {
			return GetFullNameSpace(schema) + "." + typeName;
        }else 
			return typeName;

    }

	private static string GetTypeNameFromFilePath(string filePath)
    {
		var path = filePath.Replace(@"/",@"\");
		var typeName =  path.Substring(path.LastIndexOf(@"\")+1).Replace(".json", "");

		return typeName;
    }

	private string MapSchemaPropertyTypeToCSTypeName(JsonObjectType type, JsonProperty property)
    { 
		if(property.HasSchemaReference)
			return GetTypeNameFromDocumentFilePath(property.SchemaReference, true);

        switch (type)
        {
            case JsonObjectType.Null | JsonObjectType.Integer: 
                if(property.Format == "int32")
					return "int?";
				else 
					return "long?";

            case JsonObjectType.Integer: 
                if(property.Format == "int32")
					return "int";
				else 
					return "long";
			case JsonObjectType.Boolean:
					return "bool";
			case JsonObjectType.String:
			case JsonObjectType.Null | JsonObjectType.String:
				if(property.Format == "date-time")
					return "System.DateTimeOffset";
				else if(property.IsEnumeration)
					return ApplyCamelCasing(property.Name);
				else 
					return "string";
			case NJsonSchema.JsonObjectType.Array | NJsonSchema.JsonObjectType.Null:
			case NJsonSchema.JsonObjectType.Array :
				return "System.Collections.Generic.List<" + FindCollectionItemTypeName(property, true) + ">";
			default :
				return "object";
        }
		
    }

	private string FindCollectionItemTypeName(JsonProperty property, bool includeFullyQualifiedNameSpace)
    {
		if(property.Item.SchemaReference != null)
			return GetTypeNameFromDocumentFilePath(property.Item.SchemaReference, includeFullyQualifiedNameSpace);
		else  
			return MapSchemaPropertyTypeToCSTypeName(property.Item.Type, property);
		    //return FindSchemaDefinitionNameByProperties(property.Item.SchemaReference.ActualProperties, schemaDefinitions);
    }

	private string FindSchemaDefinitionNameByProperties(IReadOnlyDictionary<string, JsonProperty> properties, IDictionary<string, NJsonSchema.JsonSchema4> schemaDefinitions)
    {
		foreach(var def in schemaDefinitions)
        {
			var found = true;
			foreach(var property in properties) 
            {
				if(!def.Value.ActualProperties.Any(r=>r.Key == property.Key))
                {
					found = false;
					break;
                }
            }
			if(found)
				return def.Key;
        }
		return "object";
    }

	private static string ApplyCamelCasing(string jsonPropertyName)
    {
        if(jsonPropertyName.Length == 0 || jsonPropertyName.Length == 1)
			return "";
		string[] namePart = jsonPropertyName.Split('.');
		string fullName = "";

		foreach(var part in namePart) {
			var firstChar = part[0].ToString();
			firstChar = firstChar.ToUpper();
			var rest = part.Remove(0,1);
			var partName = firstChar + rest;
		
			fullName = fullName + "." + partName;
        }

		return fullName.Trim('.');
    }

	private void IncludeCreatedFileToProject(Project dteProject, string filePath)
    {
		var projectItem = dteProject.ProjectItems.AddFromFile(filePath);
    }

	void SaveOutput(string folderName, string outputFileName)
	{
		string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
		templateDirectory = Path.Combine(templateDirectory, folderName);
		string outputFilePath = Path.Combine(templateDirectory, outputFileName);
		File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString(), Encoding.Default); 

		this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
	}
#>